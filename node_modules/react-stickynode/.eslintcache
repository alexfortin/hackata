{"/Users/hankxiao/Codes/react-stickynode/Gruntfile.js":{"size":10215,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/Gruntfile.js","messages":[],"errorCount":0,"warningCount":0}},"/Users/hankxiao/Codes/react-stickynode/index.js":{"size":46,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/index.js","messages":[],"errorCount":0,"warningCount":0}},"/Users/hankxiao/Codes/react-stickynode/src/Sticky.jsx":{"size":11980,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/src/Sticky.jsx","messages":[],"errorCount":0,"warningCount":0,"output":"/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n/* global window, document */\n\n'use strict';\n\nvar React = require('react');\n\nvar classNames = require('classnames');\nvar propTypes = React.PropTypes;\nvar shallowCompare = require('react-addons-shallow-compare');\nvar subscribe = require('subscribe-ui-event').subscribe;\n\n// constants\nvar STATUS_ORIGINAL = 0; // The default status, locating at the original position.\nvar STATUS_RELEASED = 1; // The released status, locating at somewhere on document but not default one.\nvar STATUS_FIXED = 2; // The sticky status, locating fixed to the top or the bottom of screen.\nvar TRANSFORM_PROP = 'transform';\n\n// global variable for all instances\nvar doc;\nvar docBody;\nvar docEl;\nvar enableTransforms = true; // Use transform by default, so no Sticky on lower-end browser when no Modernizr\nvar M;\nvar scrollDelta = 0;\nvar scrollTop = -1;\nvar win;\nvar winHeight = -1;\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n    win = window;\n    doc = document;\n    docEl = doc.documentElement;\n    docBody = doc.body;\n    scrollTop = docBody.scrollTop + docEl.scrollTop;\n    winHeight = win.innerHeight || docEl.clientHeight;\n    M = window.Modernizr;\n    // No Sticky on lower-end browser when no Modernizr\n    if (M) {\n        enableTransforms = M.csstransforms3d;\n        TRANSFORM_PROP = M.prefixed('transform');\n    }\n}\n\nclass Sticky extends React.Component {\n    constructor (props, context) {\n        super(props, context);\n        this.handleResize = this.handleResize.bind(this);\n        this.handleScroll = this.handleScroll.bind(this);\n        this.handleScrollStart = this.handleScrollStart.bind(this);\n        this.delta = 0;\n        this.stickyTop = 0;\n        this.stickyBottom = 0;\n\n        this.bottomBoundaryTarget;\n        this.topTarget;\n        this.subscribers;\n\n        this.state = {\n            top: 0, // A top offset px from screen top for Sticky when scrolling down\n            bottom: 0, // A bottom offset px from screen top for Sticky when scrolling up *1*\n            width: 0, // Sticky width\n            height: 0, // Sticky height\n            x: 0, // The original x of Sticky\n            y: 0, // The original y of Sticky\n            topBoundary: 0, // The top boundary on document\n            bottomBoundary: Infinity, // The bottom boundary on document\n            status: STATUS_ORIGINAL, // The Sticky status\n            pos: 0, // Real y-axis offset for rendering position-fixed and position-relative\n            activated: false // once browser info is available after mounted, it becomes true to avoid checksum error\n        };\n    }\n\n    getTargetHeight (target) {\n        return target && target.offsetHeight || 0;\n    }\n\n    getTopPosition () {\n        var self = this;\n        // TODO, topTarget is for current layout, may remove\n        var top = self.props.top || self.props.topTarget || 0;\n        if (typeof top === 'string') {\n            if (!self.topTarget) {\n                self.topTarget = doc.querySelector(top);\n            }\n            top = self.getTargetHeight(self.topTarget);\n        }\n        return top;\n    }\n\n    getTargetBottom (target) {\n        if (!target) {\n            return -1;\n        }\n        var rect = target.getBoundingClientRect();\n        return scrollTop + rect.bottom;\n    }\n\n    getBottomBoundary () {\n        var self = this;\n\n        var boundary = self.props.bottomBoundary;\n\n        // TODO, bottomBoundary was an object, depricate it later.\n        if (typeof boundary === 'object') {\n            boundary = boundary.value || boundary.target || 0;\n        }\n\n        if (typeof boundary === 'string') {\n            if (!self.bottomBoundaryTarget) {\n                self.bottomBoundaryTarget = doc.querySelector(boundary);\n            }\n            boundary = self.getTargetBottom(self.bottomBoundaryTarget);\n        }\n        return boundary && boundary > 0 ? boundary : Infinity;\n    }\n\n    reset () {\n        this.setState({\n            status: STATUS_ORIGINAL,\n            pos: 0\n        });\n    }\n\n    release (pos) {\n        this.setState({\n            status: STATUS_RELEASED,\n            pos: pos - this.state.y\n        });\n    }\n\n    fix (pos) {\n        this.setState({\n            status: STATUS_FIXED,\n            pos: pos\n        });\n    }\n\n    /**\n     * Update the initial position, width, and height. It should update whenever children change.\n     */\n    updateInitialDimension () {\n        var self = this;\n\n        self.timer = +new Date;\n        var outer = self.refs.outer;\n        var inner = self.refs.inner;\n        var outerRect = outer.getBoundingClientRect();\n\n        var width = outer.offsetWidth;\n        var height = inner.offsetHeight;\n        var outerY = outerRect.top + scrollTop;\n\n        self.setState({\n            top: self.getTopPosition(),\n            bottom: Math.min(self.state.top + height, winHeight),\n            width: width,\n            height: height,\n            x: outerRect.left,\n            y: outerY,\n            bottomBoundary: self.getBottomBoundary(),\n            topBoundary: outerY\n        });\n    }\n\n    handleResize (e, ae) {\n        winHeight = ae.resize.height;\n        this.updateInitialDimension();\n        this.update();\n    }\n\n    handleScrollStart (e, ae) {\n        scrollTop = ae.scroll.top;\n        this.updateInitialDimension();\n    }\n\n    handleScroll (e, ae) {\n        scrollDelta = ae.scroll.delta;\n        scrollTop = ae.scroll.top;\n        this.update();\n    }\n\n    /**\n     * Update Sticky position.\n     * In this function, all coordinates of Sticky and scren are projected to document, so the local variables\n     * \"top\"/\"bottom\" mean the expected top/bottom of Sticky on document. They will move when scrolling.\n     *\n     * There are 2 principles to make sure Sticky won't get wrong so much:\n     * 1. Reset Sticky to the original postion when \"top\" <= topBoundary\n     * 2. Release Sticky to the bottom boundary when \"bottom\" >= bottomBoundary\n     *\n     * If \"top\" and \"bottom\" are between the boundaries, Sticky will always fix to the top of screen\n     * when it is shorter then screen. If Sticky is taller then screen, then it will\n     * 1. Fix to the bottom of screen when scrolling down and \"bottom\" > Sticky current bottom\n     * 2. Fix to the top of screen when scrolling up and \"top\" < Sticky current top\n     * (The above 2 points act kind of \"bottom\" dragging Sticky down or \"top\" dragging it up.)\n     * 3. Release Sticky when \"top\" and \"bottom\" are between Sticky current top and bottom.\n     */\n    update () {\n        var self = this;\n\n        if (self.state.bottomBoundary - self.state.topBoundary <= self.state.height || !self.props.enabled) {\n            if (self.state.status !== STATUS_ORIGINAL) {\n                self.reset();\n            }\n            return;\n        }\n\n        var delta = scrollDelta;\n        var top = scrollTop + self.state.top;\n        var bottom = scrollTop + self.state.bottom;\n\n        if (top <= self.state.topBoundary) {\n            self.reset();\n        } else if (bottom >= self.state.bottomBoundary) {\n            self.stickyBottom = self.state.bottomBoundary;\n            self.stickyTop = self.stickyBottom - self.state.height;\n            self.release(self.stickyTop);\n        } else {\n            if (self.state.height > winHeight) {\n                // In this case, Sticky is larger then screen\n                switch (self.state.status) {\n                    case STATUS_ORIGINAL:\n                        self.release(self.state.y);\n                        self.stickyTop = self.state.y;\n                        self.stickyBottom = self.stickyTop + self.state.height;\n                        break;\n                    case STATUS_RELEASED:\n                        if (delta > 0 && bottom > self.stickyBottom) { // scroll down\n                            self.fix(self.state.bottom - self.state.height);\n                        } else if (delta < 0 && top < self.stickyTop) { // scroll up\n                            this.fix(self.state.top);\n                        }\n                        break;\n                    case STATUS_FIXED:\n                        var isChanged = true;\n                        if (delta > 0 && self.state.pos === self.state.top) { // scroll down\n                            self.stickyTop = top - delta;\n                            self.stickyBottom = self.stickyTop + self.state.height;\n                        } else if (delta < 0 && self.state.pos === self.state.bottom - self.state.height) { // up\n                            self.stickyBottom = bottom - delta;\n                            self.stickyTop = self.stickyBottom - self.state.height;\n                        } else {\n                            isChanged = false;\n                        }\n\n                        if (isChanged) {\n                            self.release(self.stickyTop);\n                        }\n                        break;\n                }\n            } else {\n                self.fix(self.state.top);\n            }\n        }\n        self.delta = delta;\n    }\n\n    componentWillReceiveProps () {\n        this.forceUpdate();\n    }\n\n    componentWillUnmount () {\n        var subscribers = this.subscribers || [];\n        for (var i = subscribers.length - 1; i >= 0; i--) {\n            this.subscribers[i].unsubscribe();\n        }\n    }\n\n    componentDidMount () {\n        var self = this;\n        if (self.props.enabled) {\n            self.setState({activated: true});\n            self.updateInitialDimension();\n            self.subscribers = [\n                subscribe('scrollStart', self.handleScrollStart.bind(self), {useRAF: true}),\n                subscribe('scroll', self.handleScroll.bind(self), {useRAF: true, enableScrollInfo: true}),\n                subscribe('resize', self.handleResize.bind(self), {enableResizeInfo: true})\n            ];\n        }\n    }\n\n    translate (style, pos) {\n        if (enableTransforms && this.state.activated) {\n            style[TRANSFORM_PROP] = 'translate3d(0,' + pos + 'px,0)';\n        } else {\n            style.top = pos;\n        }\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        return shallowCompare(this, nextProps, nextState);\n    }\n\n    render () {\n        var self = this;\n        // TODO, \"overflow: auto\" prevents collapse, need a good way to get children height\n        var style = {\n            overflow: 'hidden',\n            position: self.state.status === STATUS_FIXED ? 'fixed' : 'relative',\n            top: self.state.status === STATUS_FIXED ? '0' : ''\n        };\n\n        // always use translate3d to enhance the performance\n        self.translate(style, self.state.pos);\n        if (self.state.status !== STATUS_ORIGINAL) {\n            style.width = self.state.width;\n        }\n\n        return (\n            <div ref='outer' className={classNames('sticky-outer-wrapper', self.props.className)}>\n                <div ref='inner' className='sticky-inner-wrapper' style={style}>\n                    {self.props.children}\n                </div>\n            </div>\n        );\n    }\n}\n\nSticky.defaultProps = {\n    enabled: true,\n    top: 0,\n    bottomBoundary: 0\n};\n\n/**\n * @param {Bool} enabled A switch to enable or disable Sticky.\n * @param {String/Number} top A top offset px for Sticky. Could be a selector representing a node\n *        whose height should serve as the top offset.\n * @param {String/Number} bottomBoundary A bottom boundary px on document where Sticky will stop.\n *        Could be a selector representing a node whose bottom should serve as the bottom boudary.\n */\nSticky.propTypes = {\n    enabled: propTypes.bool,\n    top: propTypes.oneOfType([\n        propTypes.string,\n        propTypes.number\n    ]),\n    bottomBoundary: propTypes.oneOfType([\n        propTypes.object,  // TODO, may remove\n        propTypes.string,\n        propTypes.number\n    ])\n};\n\nmodule.exports = Sticky;\n"}},"/Users/hankxiao/Codes/react-stickynode/tests/functional/sticky-functional.jsx":{"size":2176,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/tests/functional/sticky-functional.jsx","messages":[],"errorCount":0,"warningCount":0}},"/Users/hankxiao/Codes/react-stickynode/tests/functional/sticky.spec.js":{"size":1466,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/tests/functional/sticky.spec.js","messages":[],"errorCount":0,"warningCount":0}},"/Users/hankxiao/Codes/react-stickynode/tests/unit/Sticky-test.js":{"size":9214,"mtime":1450408336000,"hashOfConfig":"eecd3218621bdf2993d0aa21c76b40ed","results":{"filePath":"/Users/hankxiao/Codes/react-stickynode/tests/unit/Sticky-test.js","messages":[],"errorCount":0,"warningCount":0}}}